[mu [(program)]
[;; { Control-flow primitives for the case when the number of harts is large enough that all
  instructions, including loads, finish in one thread cycle. }]

[;; { delay for k cycles. TODO: use loops when k > 2 + 1 }]
[def (delay [-> block!]) [lam [(k num!)]
  [repeat k {nop}]]]

[;; { execute block if condition is true in time = (2 + cycles of block) }]
[def (ifelse [-> block!]) [lam [(condition condition!) (do-if block!) (do-else block!)]
  [def (ifcycles) [cycles? do-if]]
  [def (elsecycles [<=! ifcycles]) [cycles? do-else]]
  [def (assembly block!) {
    [[condition {ELSE}] false]
    [id do-if]
    j DONE
    ELSE:
    [id do-else]
    [delay [+ 1 [- ifcycles elsecycles]]]
    DONE:
    }]
  [;; { overhead = time to branch/not branch + time to jump }]
  [[unsafe-assert-exact-cycles [+ 2 ifcycles]] assembly]]]
[def (if+2) [lam [(condition condition!) (instrs block!)] [ifelse condition instrs {}]]]
[def (best)
  [lam [(compare [-> condition!])]
  [lam [(rd output!) (rs1 input!) (rs2 input!)]
  [ifelse [compare rs1 rs2] {
    mv rd rs1
  } {
    mv rd rs2
  }]]]]
[def (max [-> block!]) [best >=]]
[def (min [-> block!]) [best <]]
[program]]
