[mu [(program)]
[def (condition!) [assertify [lam [(x)] [[hasattr {condition}] x]] {a condition}]]
[def (make-condition)
  [lam [(true-branch frag!) (false-branch frag!)]
  [lam [(rs1 reg!) (rs2 reg!)]
  [[addattr {condition}]
    [lam [(label frag!)]
      [pair {
        [id true-branch] rs1 rs2 label
      } {
        [id false-branch] rs1 rs2 label
      }]]]]]]
[def (<) [make-condition {blt} {bgeu}]]
[def (>=) [make-condition {bgeu} {blt}]]
[def (==) [make-condition {beq} {bne}]]
[def (!=) [make-condition {bne} {beq}]]
[def (+acc [-> block!]) [lam [(acc input! output!) (other input!)] {add acc acc other}]]
[def (-acc [-> block!]) [lam [(acc input! output!) (other input!)] {sub acc acc other}]]
[def (branch~) [lam [(condition condition!) (asm block!)] {
  [[condition {DONE}] false]
  [id asm]
  DONE:
  }]]
[def (unroll) [lam [(n num!) (body [lamof num!] [-> block!])]
  [[[fold-range 1 0 n] {}]
  [lam [(acc) (i)] {
    [id acc]
    [body i]
  }]]]]
[def (join) [lam [(n num!) (glue block!) (body [-> [lamof num!] block!])] {
  [[[fold-range 1 0 [- n 1]] {}]
  [lam [(acc) (i)] {
    [id acc]
    [body i]
    [id glue]
  }]]
  [body [- n 1]]}]]
[def (repeat~) [lam [(n num!) (body block!)]
  [unroll n [lam [(_)] body]]]]
[def (repeat) [lam [(n num!) (body block!)]
  [[unsafe-assert-exact-cycles [* n [cycles? body]]]
    [repeat~ n body]]]]
[def (for~) [lam [
    (start reg!) (stop reg!)
    (step num! [>! 0])
    (body block!)]
  [def (addition-and-branching-cycles) [+ cycles-of-iarith cycles-of-taken-branch]]
  [def (total-cycles [lamof num!]) [lam [(num-iterations)] [-
    [* num-iterations
      [+ [cycles? body] addition-and-branching-cycles]]
    [- cycles-of-taken-branch cycles-of-not-taken-branch]]]]
  [def (assembly) {
    LOOP:
    [id body]
    addi start start step
    blt start stop LOOP
  }]
  [pair assembly total-cycles]]]
[def (for) [lam [
    (counter reg!)
    (clobber clobber!)
    (start num!)
    (stop num! [>! start])
    (step num! [>! 0])
    (body block!)]
  [def (stopreg) clobber]
  [def (startup) {
    li counter start
    li stopreg stop
  }]
  [def (num-iterations) [/ [- stop start] step]]
  [def (assembly,cycles pair!) [for~ counter stopreg step body]]
  {
    [id startup]
    [
      [unsafe-assert-exact-cycles
        [[assembly,cycles false] num-iterations]]
      [assembly,cycles true]]
  }]]
[def (prologue-epilogue!) [∘ [lamof [∘ num! [∘ [>=! 0] [<! 12]]]] [-> block!]]]
[def (stackpush) [lam [(s/t/a frag!)] [lam [(n)]
  [[[fold-range 1 0 n] {addi sp sp [* 4 n]}]
    [lam [(acc block!) (k num!)] {
      sw [id s/t/a][id k] [* 4 k](sp)
      [id acc]
    }]]]]]
[def (stackpop) [lam [(s/t/a frag!)] [lam [(n)]
  [[[fold-range 1 0 n] {addi sp sp [* -4 n]}]
    [lam [(acc block!) (k num!)] {
      [id acc]
      lw [id s/t/a][id k] [* 4 k](sp)
    }]]]]]
[def (file) [lam [(function-names frag!) (body block!)]
  [mu []
    [[println {.global [id function-names]}]]
    [[println {.section .text}]]
    [[println body]]
    [[println {.end}]]]]]
[def (prologue prologue-epilogue!) [stackpush {s}]]
[def (epilogue prologue-epilogue!) [stackpop {s}]]
[def (busywait) [lam [(load [-> [lamof output!] block!]) (c0 clobber!)] {
  LOOP:
  [load c0]
  beqz c0 LOOP}]]
[def (init-allocate [-> block!]) [lam [(clobber0 clobber!)] {
  li clobber0 4
  sw clobber0 0(gp)
}]]
[def (allocate [-> block!])
  [lam [(nwords num!) (ptr output!)] {
    lw ptr 0(gp)
    addi ptr ptr [* 4 nwords]
    sw ptr 0(gp)
    addi ptr ptr [* -4 nwords]
    add ptr ptr gp
  }]]
[def (a0) {a0}] [def (a1) {a1}] [def (a2) {a2}] [def (a3) {a3}] [def (a4) {a4}] [def (a5) {a5}] [def (a6) {a6}] [def (a7) {a7}]
[def (t0) {t0}] [def (t1) {t1}] [def (t2) {t2}] [def (t3) {t3}] [def (t4) {t4}] [def (t5) {t5}] [def (t6) {t6}]
[def (s0) {s0}] [def (s1) {s1}] [def (s2) {s2}] [def (s3) {s3}] [def (s4) {s4}] [def (s5) {s5}] [def (s6) {s6}] [def (s7) {s7}] [def (s8) {s8}] [def (s9) {s9}] [def (s10) {s10}] [def (s11) {s11}]
[def (zero) {zero}] [def (ra) {ra}] [def (sp) {sp}] [def (gp) {gp}] [def (tp) {tp}]
[program]]
